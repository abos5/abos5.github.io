[{"title":"multiple-server-unit-solution (异地多单元多主架构方案)","date":"2017-08-01T12:48:29.000Z","path":"2017/08/01/skills/distribute/multiple-server-unit-solution/","text":"","tags":[{"name":"distributed-server-side-system","slug":"distributed-server-side-system","permalink":"http://yii2cms.com/tags/distributed-server-side-system/"}]},{"title":"阿里云服务器 oss 的使用","date":"2017-07-30T15:52:42.000Z","path":"2017/07/30/skills/aliyun/oss/","text":"创建一个简单的bucket用来放公网访问的图片资源异常方便不过还是建议用自有域名cname过去比较好， 方便以后迁移","tags":[{"name":"aliyun oss","slug":"aliyun-oss","permalink":"http://yii2cms.com/tags/aliyun-oss/"}]},{"title":"redis-cluster-debug-log about","date":"2017-07-30T15:52:42.000Z","path":"2017/07/30/skills/redis/redis-cluster-debug-log-of-crash/","text":"背景(background) 公司： xxx 业务: 评论 问题: 备注: 刚到公司一个多月的我，在没有任何人指导、讲解任何业务的情况下努力争取熟悉业务、努力融入到业务同事的社交环境去。 问题详情怎样讲好一个故事。 redis 集群节点释放内存也是很坑 问题总结 Redis 机器不要与业务机器放到一起， 否则CPU之间会互相影响 Redis 集群的内存配置要规划好，同一机器上的 redis集群内存总和不要大于机器内存 高并发业务不能写上一个固定的key，否则会对一个节点进行大量查询， 相当于原本发放到x个节点的压力集中到1个节点去了，失去了集群的意义 守护进程脚本请求数据时要有sleep， 不能持续请求mysql, redis等服务， 否则会造成大量压力 守护进程必须设置在一段时间后自行退出，不能跑太久， 否则会出现服务异常导致奇异bug。 主从节点不能防在同一台。 当某节点出现qps、cpu表现比其他更高、有异常的时候则可以考虑用strace对那个server进行监控，看看是哪些命令常驻， 大部分时候是一些没有分布式特性的key(strace -p 54235 -e read -s 1024 -o 54235.strace.log 这个命令拯救世界) 当一个url请求里，redis请求可能获取不到数据、且事务性要求不高时，可以在超时、异常时直接断开，返回500， 让其他请求可以顺利进行。(或者不一定每个redis命令失败时都断开， 只需要断开入口处常用的)","tags":[{"name":"redis cluster C10K","slug":"redis-cluster-C10K","permalink":"http://yii2cms.com/tags/redis-cluster-C10K/"}]},{"title":"picking-up-scrapy-to-crawl-netease-music","date":"2017-05-28T13:09:56.000Z","path":"2017/05/28/picking-up-scrapy-to-crawl-netease-music/","text":"menu picking up and review coding storage picking up and reviewScrapy 1.2.1 12source /path/to/virtualenv/scrapy/bin/activatecd /path/to/scrapyprojects/","tags":[{"name":"python scrapy netease music","slug":"python-scrapy-netease-music","permalink":"http://yii2cms.com/tags/python-scrapy-netease-music/"}]},{"title":"understanding nodejs co","date":"2017-04-23T14:42:42.000Z","path":"2017/04/23/skills/nodejs/understanding-nodejs-co/","text":"参考来源 nodejs 异步 callback 直接了当，无需理解就明白原理，但 debug 和调试难度大 generator 用 “同步” 的形式编写异步的代码 promise + generator 的解决方案 co 提供了自动 then/next 的功能 generator yield 虽然是迭代器，但在 co 里， 本身已经是同步的逻辑放置到 yield 后没有意义 yield 后必须跟异步的逻辑、语句 yield 跟 普通函数、数字、计算 没有意义（同1, 对应了 co 接受的 thunk 必须是接受一个第一个参数为异常、第二个参数为返回值的 callback， 传入其它的函数会导致 co 继续 ） promise promise 的初始化是立刻执行的 promise 等待着 resolve/reject 的召唤 co co 的目的是 自动 then/next， 没了 co 的返回必然是 Promise co resolve/reject 的作用是后续的 then 的绑定事件可以继续了 thunkify (delay execution of a function)粗暴地讲， generator thunkified 之后，需要强化的意识， generator 的执行是被切割的， 每一层之间是被阻塞、中断掉的。被分割的逻辑可以被看成3个部分 generator 里至当前 yield 之前的逻辑 generator 里当前 yield 后一语句逻辑 generator 外执行被延迟的实际逻辑 一个有 n 个 yield 的 generator 正常的执行逻辑: 初始化 -&gt; 返回函数指针 第1个 next() -&gt; 抵达第1个 yield, 并返回 yield 后一语句的值(函数) 第1个 yield 返回的函数 -&gt; 执行实际被延迟的逻辑， 此时，关键的地方来了， 第2个 next() 由谁触发?答案： 必须是在实际被延迟的逻辑执行完毕时触发， 触发方式是回调, 协议是第1个参数为错误信息，第2个参数为第2个 next() 的参数， 即是第一个 yield 的左值 抵达第2个 yield 示例代码123456789101112131415161718192021222324252627var fs = require('fs');var path = require('path')function readFile(fileName) &#123; return function(callback) &#123; fs.readFile(fileName, function(err, data) &#123; callback(err, data.toString()); &#125;); &#125;&#125;var gen = function*() &#123; console.log('next 1') var res1 = yield readFile(path.join(__dirname, '1.txt')); console.log(res1); // 1.txt中的内容 var res2 = yield readFile(path.join(__dirname, '2.txt')); console.log(res2); // 2.txt中的内容 return 'test3';&#125;var g = gen();console.log('initialized')g.next().value(function(err, res) &#123; g.next(res).value(function(err, res) &#123; console.log(g.next(res)); // &#123; value: 'test3', done: true &#125; &#125;);&#125;);","tags":[{"name":"nodejs generator eggjs","slug":"nodejs-generator-eggjs","permalink":"http://yii2cms.com/tags/nodejs-generator-eggjs/"}]},{"title":"python basic syntax","date":"2017-03-29T12:24:42.000Z","path":"2017/03/29/skills/python/syntax/","text":"loop12345use index to iterate two listfor i in list1: list1[i] = 2 list2[i] = 3","tags":[{"name":"python27","slug":"python27","permalink":"http://yii2cms.com/tags/python27/"}]},{"title":"Hello World","date":"2017-03-29T10:22:59.000Z","path":"2017/03/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]